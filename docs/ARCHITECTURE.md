# MyMonero Desktop & Mobile Apps

![Logo](./assets/logo.png_ "Logo")

## Architecture notes

In brief review, the requirements for the v1 native desktop app were that it…

* could run cross-platform,

* reproduced at least the functionality of the existing web wallet,

* could store arbitrary encrypted structured data locally,

* kept local data up-to-date with the server's,

* would facilitate things like swapping out the service provider (or at least the host), and potentially supporting multiple currencies in the future,

* (similarly) could be understood, built on top of, expanded, changed, and maintained as a long-lived codebase with a minimum of difficulty, complexity, and growth in entropy, 

* allowed us to actually release a minimum-viable app as quickly as possible (tension with previous point), and that it

* could be easily turned into a downloadable mobile app, preferably with a native UI.

### "Cross platform"

In order to avoid rewriting the same app across Mac, Windows, and Linux, we opted to use Electron. Electron is basically a Node.JS runtime, plus libraries to expose system services, plus Chrome browser windows for custom UI.

This had the obvious downside that we had to build all of our components from scratch – or at least out of existing web components.

React and React Native were considered in depth, and is discussed below.

### "Reproduced functionality of existing web wallet"

The web wallet was built entirely upon a now-aging version of Angular, which means almost all application objects were built in the Angular style. Borrowing any of the functionality would require an Angular dependency. Angular was removed as a dependency, resulting in the natural choice to factor business logic into encapsulated modules with simple public interfaces [see 1, 2]. For the moment, a context object which references application controllers is constructed and passed to application object constructors as a form of dependency injection [3]. This work also included some clarifications to codepaths like transaction construction in send-funds operations. Note that mnemonic wordset is now automatically detected, and mnemonic language selection from user locale is also attempted.

Additionally, many of the dependency scripts in the web wallet needed to be exposed as importable JS modules [3]. Note that the wallet mnemonic generation in the desktop version are now generated by the Node.JS crypto library's `randomBytes` function [4].

1. `local_modules/Wallets`, `local_modules/OpenAlias`

2. `local_modules/runtime_context` and implementors in `electron_main` and `MainWindow`

3. `local_modules/monero_utils`, `local_modules/cryptonote_utils`

4. `local_modules/cryptonote_utils/mnemonic.js` 

### "Store arbitrary encrypted structured data locally"

SQLite was considered as an embedded database but we opted for [NeDB](https://github.com/louischatriot/nedb) instead as it is not only JS-only but has a familiar document-based interface, a natural match for Javascript [1]. LMDB was not discussed initially but may be very interesting later on.

In order to accomplish password-protection we developed symmetric string and JSON document encryption libraries [2]. (Seeking community review.) Encrypting at database (de)serialization time was investigated but revealed to be a non-starter for a various reasons. Instead, the database doesn't know about the encryption and consumers are responsible for responding to events such as password changes.

In an Electron app, there is the main process, and then one process for each browser window you open. IPC is the method to communicate between them. If any long-running is performed on a thread it will block the associated UI. For example, blocking the main thread blocks the entire app. Blocking a browser process blocks the entire window, including its web contents. It was discovered that database operations blocked the thread upon which they were run. For that reason concurrency was implemented by way of an abstraction over spawning a child process and performing IPC with it [3].

On idle timeout, the in-memory decrypted data / runtime is torn down. Once the user enters their password, the runtime is reconstructed [4]. 

1. `local_modules/DocumentPersister`

2. `local_modules/symmetric_cryptor`

3. `local_modules/electron_background`, `local_modules/BackgroundDocumentPersister.NeDB.(child, electron).js`

4. `local_modules/Passwords`, `local_modules/UserIdle`, `local_modules/WalletsList`, `local_modules/Contacts`, `local_modules/RequestFunds`

### "Kept local data up-to-date"

The Wallets code currently polls for updates to account info, scan heights, transactions, etc. [1] but we're working on an effective rebuild of the back-end which will allow us to use a real-time connection for data sync (see Roadmap).

All API calls (such as submitting a constructed transaction for a send-funds operation) are done via an HTTP client [2] which is instantiated in the renderer process (rather than main) and which uses the `xhr` module, to get support for different network configurations via the browser.

1. `local_modules/Wallets/Controllers/WalletHostPollingController.js`

2. `local_modules/HostedMoneroAPIClient`


### "Could be easily turned into a native mobile app"

#### Language considerations

Single codebase for all platforms is the obvious ideal, but it doesn't appear to exist yet.

Fully native codebase was definitely considered, but would have taken too long as a first step. 


#### React vs Angular vs Bare metal

For the UI, in order to be able to generate a fully native UI on mobile, React and React Native were seriously considered, but reluctantly not able to be chosen. Initially, we knew Electron needed web output, rather than the native UI we wanted for mobile. However, React and React Native template code is not the same. So out of the gate, it was no longer a single-write solution - but actually a higher level language. To use a single codebase, in theory, it was discovered we could write the UI in React Native code first, and then use a library called [React Native for Web](https://github.com/necolas/react-native-web) to compile it to web output for Electron. Unfortunately, as of late last year when this was being evaluated, that project was not official, didn't have proper support for lists and navigation views, may have been subject to change, and would have required expanding it (and therefore maintaining it) in order to implement various custom behaviors, and complicated the codebase. As the investigation into using React itself proceeded, there were various other architectural, packaging, and maintenance caveats discovered which made us unable to base all UI code on React despite the possibility of having a mobile UI out the gate. However, since React can be added selectively, this may be an option down the road.

React does solve one of the main drawbacks of browser-side development – the option to integrate styling with executable code. (This is, in fact, how UI building is generally done on platforms other than the web.)

In fact, to get as close as possible to the time-tested approach in native UI development, a very lightweight view hierarchy toolkit [1] was written in JS to mimick how UIs are built/managed under imperative object-oriented SDKs such as Apple's UIKit. Instead of Views being backed by CALayers as they are on iOS, they are simply backed by DOM elements. This system has numerous benefits, and was used to quickly reproduce the workhorse components used throughout the app, such as the stack navigation view, modal presentation, tab bar view, lists (tables), etc. [2]. One important difference to remember is that these DOM Views are styled by CSS, which means they do not have a `layoutSubviews` function, as exists on iOS (it would be great to find a way to implement one). 

In some cases, building a standlone module for a component was not justified, and it was either left in instantiators' code (if specific to context) or, if reusable, factored out into a function in the "Common Components" module [3].

In order to facilitate and encourage keeping styles bundled within executable Javascript UI code, utility functions for lazily injecting CSS rules and stylesheets were written [4].

#### Transitioning to native

There are many options for the transition to an all-native mobile UI which are currently under consideration. The plan is to first release a native wrapper version of the app using the existing web-based UI implementation. At that point, the UI may either be moved to native piecemeal based on high value targets, or all in one go.

#### Platform agnosticism / portability

As the goal is to make the web UI immediately runnable on mobile, this means the view code must eventually talk to code objects which interface with Electron-specific services.

For that reason, in all such places, "interface" style base classes have been established, which must be "concretely" implementated per platform. Examples include the system dialog and filesystem UI modules [5]. 

Additionally, it is necessary for code for multiple platforms or for different processes (yet which are within the same domain) to cohabitate within a given module. 

For example, if concurrency under Electron weren't an issue, code could simply use `DocumentPersister.NeDB.js` instead of `BackgroundDocumentPersister.NeDB.electron.js` which has exactly the same interface, meaning consumers don't have to know they're on Electron and use the new version.

Similarly, DOM-only components are given a `.web.js` suffix. This is so that in the future we can implement, for example, an iOS only version of that specific view. (This is another convention borrowed from React Native.)

All of these conventions together enable code to remain organized and connected very modularly.

1. `local_modules/Views/View.web.js`

2. `local_modules/StackNavigation`, `local_modules/TabBarView`, `local_modules/Lists`

3. `local_modules/MMAppUICommonComponents`

4. `local_modules/Views/cssRules.web`

5. `local_modules/WindowDialogs`, `local_modules/FilesystemUI`

